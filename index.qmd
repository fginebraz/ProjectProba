---
title: "Proyecto Proba"
format: html
editor: visual
---

## Fatima Ginebra, Sara Visoso, Linda Siklic

```{r}
#| output: false
library(dplyr)
library(ggplot2)
library(patchwork)
set.seed(123)
```

## PREGUNTA 1

Considere X1, X2, . . . , Xn variables aleatorias independientes e idénticamente distribuidas todas con distribució́n exponencial con media 5. También considere Y1, Y2, . . . , Ym variables aleatorias independientes e idénticamente distribuidas todas con distribució́n exponencial con media 15 e independientes de los Xis. Defina la cantidad

$T=\frac{\frac{1}{n}\sum_{i=1}^{n}X_{i}}{\frac{1}{m}\sum_{j=1}^{m}Y_{j}}$

\(a\) Tome m = 20. Simule n = 10,100,1000,1000 Xis y Yjs y sugiera una posible distribució́n.

\(b\) Tome n = 20. Simule m = 10,100,1000,1000 Xis y Yjs y sugiera una posible distribució́n.

\(c\) Encuentre la distribució́n de T

Primero, para el ejercicio a), fijaremos m=20 y corremos el ciclo for para n = 10,100,1000,1000

```{r}
m <- 20
```


```{r}
#| warning: false
# Definimos el número de observaciones para cada variable aleatoria
m <- 20

# Simulamos varios valores de T y los almacenamos en un vector

n_sim <- 1000
T_sim <- c()
graph_list <- list()
n_values <- c(10, 100, 1000, 10000)

for (j in seq_along(n_values)) {
  n <- n_values[j]
  
  for (i in 1:n_sim) {
    X <- rexp(n, rate = 1/5)
    Y <- rexp(m, rate = 1/15)
    mu_X <- mean(X)
    mu_Y <- mean(Y)
    T <- mu_X / mu_Y
    T_sim <- c(T_sim, T)
  }
  
  # Gráfica de la distribución de T
  df1 <- data.frame(T_sim)
  grafica1 <- ggplot(df1, aes(x = T_sim)) +
    geom_histogram(aes(y = after_stat(count)/sum(after_stat(count))),
                   bins = 50, linewidth = 1, fill = "blue") +
    ggtitle(paste("Densidad de T, con n =", n, "y m =", m)) +
    ylab("f(t)") + xlab("T") + theme_light()
  
  graph_list[[j]] <- grafica1
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])
```

Ahora, para el ejercicio b), fijaremos n=20 y corremos el ciclo for para m = 10,100,1000,1000
```{r}
# Definimos el número de observaciones para cada variable aleatoria
n <- 20

# Simulamos varios valores de T y los almacenamos en un vector

n_sim <- 1000
T_sim <- c()
graph_list1 <- list()
m_values <- c(10, 100, 1000, 10000)

for (j in seq_along(m_values)) {
  m <- m_values[j]
  
  for (i in 1:n_sim) {
    X <- rexp(n, rate = 1/5)
    Y <- rexp(m, rate = 1/15)
    mu_X <- mean(X)
    mu_Y <- mean(Y)
    T <- mu_X / mu_Y
    T_sim <- c(T_sim, T)
  }
  
  # Gráfica de la distribución de T
  df1 <- data.frame(T_sim)
  grafica1 <- ggplot(df1, aes(x = T_sim)) +
    geom_histogram(aes(y = after_stat(count)/sum(after_stat(count))),
                   bins = 30, linewidth = 1, fill = "blue") +
    ggtitle(paste("Densidad de T, con n =", n, "y m =", m)) +
    ylab("f(t)") + xlab("T") + theme_light()
  
  graph_list1[[j]] <- grafica1
}

(graph_list1[[1]] | graph_list1[[2]]) / (graph_list1[[3]] | graph_list1[[4]])
  
```

Sabemos que Xi ~ Exp(1/5) y Yj ~ Exp(1/15), por lo que la suma de n Xi sigue una distribución Gamma con parámetros n y 1/5, y la suma de m Yj sigue una distribución Gamma con parámetros m y 1/15. Es decir,

$\sum_{i=1}^{n}X_{i} \sim Gamma(n,\frac{1}{5})$

$\sum_{j=1}^{m}Y_{j} \sim Gamma(m,\frac{1}{15})$

Entonces, podemos reescribir T como:

$T=\frac{\frac{1}{n}\sum_{i=1}^{n}X_{i}}{\frac{1}{m}\sum_{j=1}^{m}Y_{j}} = \frac{\frac{1}{\Gamma(n)}\sum_{i=1}^{n}X_{i}}{\frac{1}{\Gamma(m)}\sum_{j=1}^{m}Y_{j}} \cdot \frac{\Gamma(m)}{\Gamma(n)}\frac{1/5}{1/15}$

donde $\Gamma(n)$ es la función gamma evaluada en n.

Por lo tanto, T sigue una distribución F con n y m grados de libertad:

$T \sim F(n, m)$

## PREGUNTA 2

Considere X1, X2, X3, ..., Xn variables aleatorias independientes e idénticamente distribuídas todas con distribución normal estándar.

Defina U

$$
\frac{\sqrt{n}[X_{1}+X_{2}+...+X_{n}]}{X_{1}^2+X_{2}^2+...+X_{n}^2}
$$ {#eq-u}

Haga n= 10, 100, 1000, 10000 simulaciones de U y sugiera una posible distribución para U

```{r}
#| warning: false


n<- 10

#Tomo las muestras aleatorias para X
X<- rnorm(n, 0, 1)

#Calculo las sumas de la X
suma_x<- sum(X) 
#El cuadrado de una normal estándar es ji cuadrada defino X^2 como Y
Y<- rchisq(n, 1)
#no creo que tomar estas muestras sirva por que no son los mismos valores de Xi y por eso no los voy a tomar 

#Encuentro el vector con los cuadrados de cada valor
cuadrados<- X^2
suma2_x <- sum(cuadrados)

#calculo el valor de U
U= (sqrt(n)*suma_x)/suma2_x

#Hago las simulaciones con n=10

n<- 10
U_sim <- numeric(n)
for(i in 1:n){
  X<-rnorm(n,0,1)
  suma_x<- sum(X) 
  cuadrados<- X^2
  suma2_x <- sum(cuadrados)
  U_sim[i]<-(sqrt(n)*suma_x)/suma2_x
}

#grafico
df_simuls10 <- data.frame(simulaciones= U_sim)
densidad10<-df_simuls10 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

grafica10<-df_simuls10 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidad10| grafica10 
graficas+  plot_annotation("Para n=10")
```

```{r}
#| warning: false
#Hago las simulaciones con n=100

n<- 100
U_sim <- numeric(n)
for(i in 1:n){
  X<-rnorm(n,0,1)
  suma_x<- sum(X) 
  cuadrados<- X^2
  suma2_x <- sum(cuadrados)
  U_sim[i]<-(sqrt(n)*suma_x)/suma2_x
}

#grafico
df_simuls100 <- data.frame(simulaciones= U_sim)
densidad100<-df_simuls100 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

grafica100<-df_simuls100 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidad100| grafica100 
graficas+  plot_annotation("Para n=100")
```

```{r}
#Hago las simulaciones con n=1000
#| warning: false

n<- 1000
U_sim <- numeric(n)
for(i in 1:n){
  X<-rnorm(n,0,1)
  suma_x<- sum(X) 
  cuadrados<- X^2
  suma2_x <- sum(cuadrados)
  U_sim[i]<-(sqrt(n)*suma_x)/suma2_x
}

#grafico
df_simuls1000 <- data.frame(simulaciones= U_sim)
densidad1000<-df_simuls1000 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

grafica1000<-df_simuls1000 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidad1000| grafica1000 
graficas+  plot_annotation("Para n=1000")
```

```{r}
#Hago las simulaciones con n=10000
#| warning: false

n<- 10000
U_sim <- numeric(n)
for(i in 1:n){
  X<-rnorm(n,0,1)
  suma_x<- sum(X) 
  cuadrados<- X^2
  suma2_x <- sum(cuadrados)
  U_sim[i]<-(sqrt(n)*suma_x)/suma2_x
}

#grafico
df_simuls10000 <- data.frame(simulaciones= U_sim)
densidad10000<-df_simuls10000 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

grafica10000<-df_simuls10000 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidad10000| grafica10000 
graficas+  plot_annotation("Para n=10000")
```

La distribución que sugerimos para U es la normal estandar, para demostrar esto la pondremos en la misma gráfica que las 10000 simulaciones y compararemos

```{r}
#grafico
#| warning: false
df_simuls10000 <- data.frame(simulaciones= U_sim)
densidad10000<-df_simuls10000 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ stat_function(fun=dnorm, args=list(mean=0, sd=1))+theme_minimal()

grafica10000<-df_simuls10000 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+ stat_function(fun=dnorm, args=list(mean=0, sd=1))+theme_minimal()

graficas<-densidad10000| grafica10000 
graficas+  plot_annotation("Para n=10000")
```

##PREGUNTA 3

Considere $X_1,X_2,...,X_n$ variables aleatorias independientes e idénticamente distribuidas todas con distribución Unif(0,5). Defina

$U=máx\{X_1,X_2,...,X_n\}-5$.

Haga n = 10, 100, 1000, 10000 simulaciones de U y sugiera una posible distribuci ́on para U

Simulamos varios valores de T y los almacenamos en un vector

```{r}
# Simulamos varios valores de T y los almacenamos en un vector
#| warning: false


n_sim <- 1000
U_sim <- numeric(n_sim)
n_values <- c(10, 100, 1000, 10000)

for (j in seq_along(n_values)) {
  n <- n_values[j]
  
  for (i in 1:n_sim) {
    X <- runif(n,min=0,max=5)
    M <- max(X)
    U_sim[i] <- M - 5
  }
  
  # Gráfica de la distribución de u
  df1 <- data.frame(U_sim)
  grafica1 <- ggplot(df1, aes(x = U_sim)) +
    geom_histogram(aes(y = after_stat(count)/sum(after_stat(count))),
                   bins = 50, linewidth = 1, fill = "blue") +
    ggtitle(paste("Densidad de U, con n =", n)) +
    ylab("f(t)") + xlab("T") + theme_light()
  
  graph_list[[j]] <- grafica1
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])

```

Podemos encontrar la distribución de $U$ utilizando la función de distribución acumulada y la transformación de variables.

Primero, encontramos la CDF de $U$:

$$\begin{aligned} F_U(u) &= P(U \leq u) \\ &= P(\max\{X_1,X_2,...,X_n\} - 5 \leq u) \\ &= P(\max\{X_1,X_2,...,X_n\} \leq u + 5) \\ &= [P(X_1 \leq u+5)]^n \\ &= \left(\frac{u+5}{5}\right)^n, \quad 0 \leq u \leq 5 \end{aligned}$$

Luego, podemos encontrar la densidad de probabilidad de $U$ tomando la derivada de la CDF:

$$\begin{aligned} f_U(u) &= \frac{d}{du}F_U(u) \\ &= n\left(\frac{u+5}{5}\right)^{n-1}\frac{1}{5}, \quad 0 \leq u \leq 5 \end{aligned}$$

Esta es la distribución de probabilidad de $U$, que podemos identificar como una distribución beta con parámetros $\alpha = 1$ y $\beta = n$:

$$U \sim \text{Beta}(1,n)$$


## PREGUNTA 4

Se lanzan 3 dados balanceados. Sea X la suma de las caras.

\(a\) Para n = 100, 1000, 10000, 100000 haga n simulaciones para obtener la función de masa de probabilidad aproximada de X.

\(b\) Usando las funciones de las librería 'patchwork' y 'ggplot2' ponga en un mismo gráafico las cuatro gráficas de las funciones de masa del inicio anterior (c) Para n = 10, . . . , 100000 haga n simulaciones para obtener un estimado de la probabilidad P(X ≤ 3). Ponga en un gráfico n en el eje horizontal y la probabilidad en el eje vertical.

Hacemos la simulación
```{r}
#| warning: false



caras_del_dado <- 1:6
num_dados <- 3


num_sim <- 100000
vector_simuls <- c()
for(i in 1:num_sim){
  simulacion <- sample(x = caras_del_dado, size = num_dados, replace = TRUE)
  valor_simulacion <- sum(simulacion)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

```

Generamos las cuatro gráficas con un ciclo for y las guardamos en una lista

```{r}
str(vector_simuls)
# Define the values of n to use
n_values <- c(100, 1000, 10000, 100000)

#| warning: false
# Create an empty list to store the graphs
graph_list <- list()

# Use a for loop to create the graphs and store them in the list
for (i in 1:length(n_values)) {
  n <- n_values[i]
  
  df <- data.frame(suma = vector_simuls[1:n])
  
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=..count../sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])

str(vector_simuls)

simuls_satisfacen <- vector_simuls <= 3

satisfacen <- simuls_satisfacen[1:i]

proba_estimada <- sum(satisfacen)/length(satisfacen)
proba_estimada


probabilidades_estimadas <- c()
for(i in 1:length(simuls_satisfacen)){
  satisfacen <- simuls_satisfacen[1:i]
  proba_estimada <- sum(satisfacen)/length(satisfacen)
  probabilidades_estimadas <- c(probabilidades_estimadas, proba_estimada)
}
```

Imprimimos la probabilidad estimada según el número de simulaciones

```{r}
#| warning: false
print(paste("la proba estimada para 100 simulaciones es", probabilidades_estimadas[[100]]))
print(paste("la proba estimada para 1000 simulaciones es", probabilidades_estimadas[[1000]]))
print(paste("la proba estimada para 10000 simulaciones es", probabilidades_estimadas[[10000]]))
print(paste("la proba estimada para 100000 simulaciones es", probabilidades_estimadas[[100000]]))

```

Observamos cómo converge la probabilidad según el número de simulaciones (cumple lo visto en clase sobre convergencia)

```{r}
df_probas <- data.frame(n = 1:length(simuls_satisfacen),
                        probabilidades = probabilidades_estimadas)

#| warning: false
df_probas %>% 
  ggplot() +
  geom_line(aes(x = n, y = probabilidades)) +
  ylab("probabilidades") + 
  xlab("n") +
  theme_light()


```

## PREGUNTA 5

5.  Una urna tiene 7 bolas numeradas del 1 al 7. Se sacan 2 bolas de la urna SIN reemplazo. Sea X la suma del nu ́meros en las bolas.

1.  \(a\) Para n = 100,1000,10000,100000 haga n simulaciones para obtener la funcio ́n de masa de probabilidad aproximada de X.

2.  \(b\) Usando las funciones de las librer ́ıa \'patchwork\' y \'ggplot2\' ponga en un mismo gra ́fico las cuatro gra ́ficas de las funciones de masa del inicio anterior.

3.  \(c\) Para n = 10, . . . , 100000 haga n simulaciones para obtener un estimado de la proba- bilidad P(X ≤ 10). Ponga en un gr ́afico n en el eje horizontal y la probabilidad en el eje vertical.


```{r}
#| warning: false



numeracion <- 1:7
num_bolas <- 7


num_sim <- 100000
vector_simuls <- c()
for(i in 1:num_sim){
  simulacion <- sample(x = numeracion, size = 2, replace = FALSE)
  valor_simulacion <- sum(simulacion)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

str(vector_simuls)
# Define the values of n to use
```

Generamos las cuatro gráficas con un ciclo for y las guardamos en una lista

```{r}
#| warning: false

n_values <- c(100, 1000, 10000, 100000)

# Create an empty list to store the graphs
graph_list <- list()

# Use a for loop to create the graphs and store them in the list
for (i in 1:length(n_values)) {
  n <- n_values[i]
  df <- data.frame(suma = vector_simuls[1:n])
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=..count../sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])

str(vector_simuls)

simuls_satisfacen <- vector_simuls <= 10

satisfacen <- simuls_satisfacen[1:i]

proba_estimada <- sum(satisfacen)/length(satisfacen)
proba_estimada


probabilidades_estimadas <- c()
for(i in 1:length(simuls_satisfacen)){
  satisfacen <- simuls_satisfacen[1:i]
  proba_estimada <- sum(satisfacen)/length(satisfacen)
  probabilidades_estimadas <- c(probabilidades_estimadas, proba_estimada)
}
```

Imprimimos la probabilidad estimada según el número de simulaciones

```{r}
#| warning: false
#| 
print(paste("la proba estimada para 100 simulaciones es", probabilidades_estimadas[[100]]))
print(paste("la proba estimada para 1000 simulaciones es", probabilidades_estimadas[[1000]]))
print(paste("la proba estimada para 10000 simulaciones es", probabilidades_estimadas[[10000]]))
print(paste("la proba estimada para 100000 simulaciones es", probabilidades_estimadas[[100000]]))

```

Observamos cómo converge la probabilidad según el número de simulaciones (cumple lo visto en clase sobre convergencia)

```{r}
df_probas <- data.frame(n = 1:length(simuls_satisfacen),
                        probabilidades = probabilidades_estimadas)

df_probas %>% 
  ggplot() +
  geom_line(aes(x = n, y = probabilidades)) +
  ylab("probabilidades") + 
  xlab("n") +
  theme_light()

```



## PREGUNTA 6

Una urna tiene 7 bolas numeradas del 1 al 7. Se sacan 2 bolas de la urna CON reemplazo. Sea X la suma del nu ́meros en las bolas.

1.  \(a\) Para n = 100,1000,10000,100000 haga n simulaciones para obtener la funcio ́n de masa de probabilidad aproximada de X.

2.  \(b\) Usando las funciones de las librer ́ıa 'patchwork' y 'ggplot2' ponga en un mismo gra ́fico las cuatro gra ́ficas de las funciones de masa del inicio anterior.

3.  \(c\) Para n = 10, . . . , 100000 haga n simulaciones para obtener un estimado de la proba- bilidad P(X ≤ 10). Ponga en un gr ́afico n en el eje horizontal y la probabilidad en el eje vertical.

```{r}
#| warning: false


numeracion <- 1:7
num_bolas <- 7

num_sim <- 100000
vector_simuls <- c()
for(i in 1:num_sim){
  simulacion <- sample(x = numeracion, size = 2, replace = TRUE)
  valor_simulacion <- sum(simulacion)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

str(vector_simuls)
# Define the values of n to use
```

Generamos las cuatro gráficas con un ciclo for y las guardamos en una lista

```{r}
n_values <- c(100, 1000, 10000, 100000)

# Create an empty list to store the graphs
graph_list <- list()

# Use a for loop to create the graphs and store them in the list
for (i in 1:length(n_values)) {
  n <- n_values[i]
  df <- data.frame(suma = vector_simuls[1:n])
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=..count../sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])

str(vector_simuls)

simuls_satisfacen <- vector_simuls <= 10

satisfacen <- simuls_satisfacen[1:i]

proba_estimada <- sum(satisfacen)/length(satisfacen)
proba_estimada


probabilidades_estimadas <- c()
for(i in 1:length(simuls_satisfacen)){
  satisfacen <- simuls_satisfacen[1:i]
  proba_estimada <- sum(satisfacen)/length(satisfacen)
  probabilidades_estimadas <- c(probabilidades_estimadas, proba_estimada)
}

```

Imprimimos la probabilidad estimada según el número de simulaciones

```{r}
print(paste("la proba estimada para 100 simulaciones es", probabilidades_estimadas[[100]]))
print(paste("la proba estimada para 1000 simulaciones es", probabilidades_estimadas[[1000]]))
print(paste("la proba estimada para 10000 simulaciones es", probabilidades_estimadas[[10000]]))
print(paste("la proba estimada para 100000 simulaciones es", probabilidades_estimadas[[100000]]))

```

Observamos cómo converge la probabilidad según el número de simulaciones (cumple lo visto en clase sobre convergencia)

```{r}
df_probas <- data.frame(n = 1:length(simuls_satisfacen),
                        probabilidades = probabilidades_estimadas)

df_probas %>% 
  ggplot() +
  geom_line(aes(x = n, y = probabilidades)) +
  ylab("probabilidades") + 
  xlab("n") +
  theme_light()

```


## PREGUNTA 7

En un salón de clases del curso de Cá́lculo de Probabilidad 2 hay 50 estudiantes. Cada estudiante pone en papel su claveú ́nica (CU) y lo introduce en una urna comú́n. Posteriormente dichxs estudiantes toman un papel de la urna. Sea X el nu ́mero de alumnos que sacaron el papelito con su clave u ́nica.

\(a\) Para n = 100,1000,10000,100000 haga n simulaciones para obtener la funcio ́n de masa de probabilidad aproximada de X.

\(b\) Usando las funciones de las librería 'patchwork' y 'ggplot2' ponga en un mismo gráfico las cuatro gráficas de las funciones de masa del inicio anterior.

\(c\) Para n = 10, . . . , 100000 haga n simulaciones para obtener un estimado de la proba- bilidad P(X ≤ 15). Ponga en un gráfico n en el eje horizontal y la probabilidad en el eje vertical.

Definimos las claves únicas y el número de simulaciones

```{r}
#| warning: false


claves <- 1:50

num_sim <- 100000
vector_simuls <- c()
for(i in 1:num_sim){
  simulacion <- sample(x = claves, size = 50, replace = FALSE)
  valor_simulacion <- sum(simulacion==claves)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

str(vector_simuls)
```

Definimos los valores de n

```{r}
n_values <- c(100, 1000, 10000, 100000)
```

Creamos una lista vacía para guardar las gráficas

```{r}
graph_list <- list()
```

Usamos un loop para crear las gráficas y guardarlas en la lista.

```{r}
#| warning: false
for (i in 1:length(n_values)) {
  n <- n_values[i]
  df <- data.frame(suma = vector_simuls[1:n])
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=after_stat(count)/sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

```

Graficamos las 4 gráficas

```{r}
#| warning: false
(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])
```

Vemos la probabilidad de que el número de personas que saquen su clave única sea menor a 15. (Probablemente sea alta, ya que en la práctica es muy difícil que simplemente 1 persona sacara su clave única)

```{r}
#| warning: false
str(vector_simuls)

simuls_satisfacen <- vector_simuls <= 15

satisfacen <- simuls_satisfacen[1:i]

proba_estimada <- sum(satisfacen)/length(satisfacen)
proba_estimada

```

Imprimimos la probabilidad estimada para 100, 1000, 10000, 100000 simulaciones y lo graficamos

```{r}
#| warning: false
probabilidades_estimadas <- c()
for(i in 1:length(simuls_satisfacen)){
  satisfacen <- simuls_satisfacen[1:i]
  proba_estimada <- sum(satisfacen)/length(satisfacen)
  probabilidades_estimadas <- c(probabilidades_estimadas, proba_estimada)
}

print(paste("la proba estimada para 100 simulaciones es", probabilidades_estimadas[[100]]))
print(paste("la proba estimada para 1000 simulaciones es", probabilidades_estimadas[[1000]]))
print(paste("la proba estimada para 10000 simulaciones es", probabilidades_estimadas[[10000]]))
print(paste("la proba estimada para 100000 simulaciones es", probabilidades_estimadas[[100000]]))

```

Observamos cómo converge la probabilidad según el número de simulaciones (cumple lo visto en clase sobre convergencia)

```{r}
df_probas <- data.frame(n = 1:length(simuls_satisfacen),
                        probabilidades = probabilidades_estimadas)

df_probas %>% 
  ggplot() +
  geom_line(aes(x = n, y = probabilidades)) +
  ylab("probabilidades") + 
  xlab("n") +
  theme_light()
```


## PREGUNTA 8:

Simule tantos n ́umeros uniformes en el intervalo (0,1) hasta que su suma sea mayor o igual\
que 1. Sea N el n ́umero de sumando requeridos para alcanzar dicho objetivo. Por ejemplo\
si obtuvo los números 0.35, 0.58, 0.22 se tiene que N = 3 (pues se necesitó 3 sumandos\
para que la suma sea mayor ́o igual que 1).

\(a\) Para n = 100, 1000, 10000, 100000 haga n simulaciones para obtener la función de\
masa de probabilidad aproximada de N .\
(b) Usando las funciones de las librería 'patchwork' y 'ggplot2' ponga en un mismo gráfico\
las cuatro gráficas de las funciones de masa del inicio anterior 2

```{r}
#| warning: false
#Comienzo haciendo una sola simulación

suma_unif <- 0
N <-0
#para encontarr un valor de N
while (suma_unif < 1) {
  #tomo las muestras 
  Xu <- runif(1, min=0, max=1)
  #En N voy contando la cantidad de veces que corre el while
  N<-N+1
  suma_unif<- suma_unif + Xu
}

#sigo con las simulaciones para distintos valores de N
#para n=100
n <- 100
N_sim<- numeric(n)
for(i in 1:n){
  suma_unif <- 0
  N <-0
  while (suma_unif < 1) {
    Xu <- runif(1, min=0, max=1)
    N<-N+1
    suma_unif<- suma_unif + Xu
  }
  N_sim[i]<- N
}
#para hacer el data frame saco la probabilidad en cada punto
df_simunif100 <- data.frame(table(N_sim)/n )
colnames(df_simunif100)<- c('N', 'Probabilidad')
#head(df_simunif100)
func_masa100 <-ggplot(data=df_simunif100)+
geom_bar(aes(x= N, y= Probabilidad ),stat = 'identity', fill='blue') +
labs(title="Para n=100")+
theme_minimal()
func_masa100

```

Ahora para n=1000

```{r}
#| warning: false
#sigo con las simulaciones para distintos valores de N
#para n=1000
n <- 1000
N_sim<- numeric(n)
for(i in 1:n){
  suma_unif <- 0
  N <-0
  while (suma_unif < 1) {
    Xu <- runif(1, min=0, max=1)
    N<-N+1
    suma_unif<- suma_unif + Xu
  }
  N_sim[i]<- N
}
#para hacer el data frame saco la probabilidad en cada punto
df_simunif1000 <- data.frame(table(N_sim)/n )
colnames(df_simunif1000)<- c('N', 'Probabilidad')
#head(df_simunif)
func_masa1000 <- df_simunif1000 %>%ggplot()+
geom_bar(aes(x= N, y= Probabilidad ),stat = 'identity', fill='blue') +
labs(title="Para n=1000")+
theme_minimal()
func_masa1000
```

Para n=10000

```{r}
#| warning: false
#sigo con las simulaciones para distintos valores de N
#para n=10000
n <- 10000
N_sim<- numeric(n)
for(i in 1:n){
  suma_unif <- 0
  N <-0
  while (suma_unif < 1) {
    Xu <- runif(1, min=0, max=1)
    N<-N+1
    suma_unif<- suma_unif + Xu
  }
  N_sim[i]<- N
}
#para hacer el data frame saco la probabilidad en cada punto
df_simunif10000 <- data.frame(table(N_sim)/n )
colnames(df_simunif10000)<- c('N', 'Probabilidad')
#head(df_simunif)
func_masa10000 <-ggplot(data=df_simunif10000)+
geom_bar(aes(x= N, y= Probabilidad ),stat = 'identity', fill='blue') +
labs(title="Para n=10000")+
theme_minimal()
func_masa10000
```

Para n=100000

```{r}
#| warning: false
#para n=100000
n <- 100000
N_sim<- numeric(n)
for(i in 1:n){
  suma_unif <- 0
  N <-0
  while (suma_unif < 1) {
    Xu <- runif(1, min=0, max=1)
    N<-N+1
    suma_unif<- suma_unif + Xu
  }
  N_sim[i]<- N
}
#para hacer el data frame saco la probabilidad en cada punto
df_simunif100000 <- data.frame(table(N_sim)/n )
colnames(df_simunif100000)<- c('N', 'Probabilidad')
#head(df_simunif)
func_masa100000 <-ggplot(data=df_simunif100000)+
geom_bar(aes(x= N, y= Probabilidad ),stat = 'identity', fill='blue') +
labs(title="Para n=100000")+
theme_minimal()
func_masa100000
```

Ahora junto todas las gráficas del inciso a en la misma gráfica

```{r}
#| warning: false
grafjuntas<- (func_masa100/ func_masa10000)| (func_masa1000/func_masa100000)
grafjuntas+ plot_annotation("Funciones masa")+plot_layout(widths = c(2,2))
```

\(c\) Para n = 10, . . . , 100000 haga n simulaciones para obtener un estimado del valor\
esperado de E(N ). Ponga en un gráfico n en el eje horizontal y el valor esperado en\
el eje vertical.

```{r}
#| warning: false
#hago simulaciones para n=10, es de lo único que todavía no tengo probabilidades calculadas
n <- 10
N_sim<- numeric(n)
for(i in 1:n){
  suma_unif <- 0
  N <-0
  while (suma_unif < 1) {
    Xu <- runif(1, min=0, max=1)
    N<-N+1
    suma_unif<- suma_unif + Xu
  }
  N_sim[i]<- N
}
#para hacer el data frame saco la probabilidad en cada punto
df_simunif10 <- data.frame(table(N_sim)/n )
colnames(df_simunif10)<- c('N', 'Probabilidad')
#calculo el valor esperado con su formula para n=10
#Primero debo asegurarme que el tipo de datos del data frame sea el correcto para poder operar con ellos
df_simunif10$N <- as.numeric(as.character(df_simunif10$N))
df_simunif10$Probabilidad <- as.numeric(df_simunif10$Probabilidad)
ve10<- sum(df_simunif10$N * df_simunif10$Probabilidad)
#Valor esperado n=100
df_simunif100$N <- as.numeric(as.character(df_simunif100$N))
df_simunif100$Probabilidad <- as.numeric(df_simunif100$Probabilidad)
ve100<- sum(df_simunif100$N * df_simunif100$Probabilidad)
#Valor esperado n=1000
df_simunif1000$N <- as.numeric(as.character(df_simunif1000$N))
df_simunif1000$Probabilidad <- as.numeric(df_simunif1000$Probabilidad)
ve1000<- sum(df_simunif1000$N * df_simunif1000$Probabilidad)
#valor esperado n=10000
df_simunif10000$N <- as.numeric(as.character(df_simunif10000$N))
df_simunif10000$Probabilidad <- as.numeric(df_simunif10000$Probabilidad)
ve10000<- sum(df_simunif10000$N * df_simunif10000$Probabilidad)
#valor esperado n=100000
df_simunif100000$N <- as.numeric(as.character(df_simunif100000$N))
df_simunif100000$Probabilidad <- as.numeric(df_simunif100000$Probabilidad)
ve100000<- sum(df_simunif100000$N * df_simunif100000$Probabilidad)
#pongo todos los valores del valor esperado en un vector y también los de n en otro
n <- c(10, 100, 1000, 10000, 100000)
EN<-c(ve10, ve100, ve1000, ve100000, ve100000)
#voy a crear un dataframe para guardad mis resultados
df_valor_esperado <- data.frame(n, EN)
df_valor_esperado

grafvaloresperado<-df_valor_esperado %>% ggplot(aes(x= n, y=EN, group=1)) + geom_line()+ geom_point()+theme_minimal()+labs(title = "E(N) para los distintos valores de n")

grafvaloresperado
```


## Pregunta 9

Considere $$X_{1}, X_{2}, X_{3}, …,X_{n} $$ variables aleatorias independientes e identicamente distribuídas, tal que $$X_{i} $$ se distribuye Unif(0,1). Sea $$X_{(2)} $$ el segundo valor más pequeño de de estas n $$X_{i} s $$

\(a\) Para n = 100, 1000, 10000, 100000 haga 10, 000 simulaciones para obtener la función de densidad de probabilidad aproximada de $$X_{(2)} $$

```{r}
#Simulaciones para n=100
n<-100
X2_sim<-numeric(10000)
for(i in 1:10000){
  X<-runif(n, min=0, max=1)
  X<-sort(X)
  X2_sim[i]<-X[2]
}
#grafico
df_simx2100 <- data.frame(simulaciones= X2_sim/10000)
densidadx2100<-df_simx2100 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

graficax2100<-df_simx2100 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidadx2100| graficax2100
graficas100<-graficas+  plot_annotation("Para n=100")
graficas100
```

Ahora para n=1000

```{r}
#Simulaciones para n=1000
n<-1000
X2_sim<-numeric(10000)
for(i in 1:10000){
  X<-runif(n, min=0, max=1)
  X<-sort(X)
  X2_sim[i]<-X[2]
}
#grafico
df_simx21000 <- data.frame(simulaciones= X2_sim)
densidadx21000<-df_simx21000 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

graficax21000<-df_simx21000 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidadx21000| graficax21000
graficas1000<-graficas+  plot_annotation("Para n=1000")
graficas1000
```

Para n= 10000

```{r}
#Simulaciones para n=10000
n<-10000
X2_sim<-numeric(10000)
for(i in 1:10000){
  X<-runif(n, min=0, max=1)
  X<-sort(X)
  X2_sim[i]<-X[2]
}
#grafico
df_simx210000 <- data.frame(simulaciones= X2_sim)
densidadx210000<-df_simx210000 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

graficax210000<-df_simx210000 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<-densidadx210000| graficax210000
graficas10000<-graficas+  plot_annotation("Para n=10000")
graficas10000
```

Para n=100000

```{r}
#Simulaciones para n=100000
n<-100000
X2_sim<-numeric(10000)
for(i in 1:10000){
  X<-runif(n, min=0, max=1)
  X<-sort(X)
  X2_sim[i]<-X[2]
}
#grafico
df_simx2100000 <- data.frame(simulaciones= X2_sim)
densidadx2100000<-df_simx2100000 %>% ggplot()+ geom_density(aes(x = simulaciones), color="red")+ theme_minimal()

graficax2100000<-df_simx2100000 %>% ggplot()+ geom_histogram(aes(x=simulaciones, y=..density..), fill="pink", alpha=0.5)+theme_minimal()

graficas<- densidadx2100000| graficax2100000
graficas100000<-graficas+  plot_annotation("Para n=100000")
graficas100000
```

\(b\) Usando las funciones de la librería 'patchwork' ponga en un mismo gráfico las cuatro gráficas de las funciones de masa del inciso (a)

```{r}
graficafinal<-(graficas100)/(graficas1000)/(graficas10000)/(graficas100000) + plot_annotation(title = 'Función de densidad aproximada de X(2)')
graficafinal
```

\(c\) ¿Qué densidad diría que tiene X(2)?

Diríamos que tiene densidad Beta (2,n-1)

Para comprobarlo pondremos una función Beta sobre las gráficas calculadas anteriormete

Para n=10000

```{r}
#grafico
n<-10000
densidadjun<- densidadx210000+ stat_function(fun=dbeta, args=list(shape1=2,shape2=n-1))
  
graficajun<-graficax210000+ stat_function(fun=dbeta, args=list(shape1=2,shape2=n-1))

graficasjun<-densidadjun| graficajun
graficasjun<-graficasjun+  plot_annotation("Comparando con la distribución Beta")
graficasjun
```

Como podemos observar si se distribuye Beta(2,n-1)

\(d\) ¿Es consistente este resultado con ejemplo teórico que se vió en clase?

$f_{X(j)}=\frac{n!}{(j-1)!(n-j)!}x^{j-1}(1-x)^{n-j}$ para el soporte $x \in (0,1)$, que es una $Beta(j,n-j+1)$ Tenemos j=2 y coincide.

## PREGUNTA 10

Considere X1, . . . , Xn variables aleatorias independientes e id ́enticamente distribuidas, Xi ∼ Unif(−1,1). Sea Xmed la mediana de estas n Xi's, i.e.

$$
X_{m e d}= \begin{cases}X_{\left(\frac{n+1}{2}\right)} & \text { si } n \text { es impar } \\ \frac{1}{2}\left[X_{\left(\frac{n}{2}\right)}+X_{\left(\frac{n}{2}+1\right)}\right] & \text { si } n \text { es par }\end{cases}
$$


\(a\) Para n = 100, 1000, 10000, 100000 haga 10, 000 simulaciones para obtener la función de densidad de probabilidad aproximada de Xmed.

\(b\) Usando las funciones de la librería 'patchwork' ponga en un mismo gráfico las cuatro gráficas de las funciones de masa del inicio (a).

\(c\) ¿Qué densidad diría que tiene Xmed?

-   Definimos los valores de n que vamos a usar

```{r}
#| warning: false
graph_list<-list()
densidad_list<-list()
n_values <- c(100, 1000,10000,100000)


a=-1
b=1
esperanza <- (a+b)/2
varianza <- ((b-a)**2)/12

for (i in 1:length(n_values)){
  n <- n_values[i]
  
  simulaciones <- replicate(10000, {
    Xmediana <- median(runif(n, min=a,max=b))
    (Xmediana - esperanza) / sqrt(varianza/n)
  })
  
  df_simuls <- data.frame(simulaciones = simulaciones)
  densidad1 <- df_simuls %>% ggplot() +
    geom_density(aes(x = simulaciones), color = "red", size = 1) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
    theme_minimal()
  densidad1
  
  grafica1 <- df_simuls %>% ggplot() +
    geom_histogram(aes(x = simulaciones, y = ..density..), 
                   size = 1, fill = "pink", alpha = 0.5) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
    theme_minimal()
  
  grafica1
  graph_list[[i]] <- grafica1
  densidad_list[[i]] <- densidad1
  
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])

(densidad_list[[1]] | densidad_list[[2]]) / (densidad_list[[3]] | densidad_list[[4]])



```

Para aproximar la distribución de la mediana de una muestra de n variables aleatorias uniformes(-1,1), podemos utilizar el teorema del límite central (TLC), que establece que la media muestral de un tamaño de muestra suficientemente grande de cualquier distribución con media y varianza finitas se distribuirá aproximadamente de forma normal.

En este caso, dado que la distribución uniforme tiene una media de 0 y una varianza de 1/3, la media muestral (y, por tanto, también la mediana muestral) de n variables aleatorias uniformes(-1,1) se distribuirá aproximadamente de forma normal con media 0 y varianza 1/(4n/3) a medida que n aumenta.

Por lo tanto, podemos decir que la distribución de la mediana muestral de n variables aleatorias uniformes(-1,1) es aproximadamente normal con media 0 y varianza 1/(4n/3).


##PREGUNTA 11


11. Considere $X_1, \ldots, X_{999}$ variables aleatorias independientes e idénticamente distribuidas Unif $[-1,1]$. También considere $X_{1000} \sim$ Unif $[200,300]$ independiente de las otras 999 variables aleatorias, i.e. en total se tienen 1000 variables aleatorias independientes.
(a) Para $n=100,1000,10000,100000$ haga $n$ simulaciones para obtener la función de densidad de probabilidad aproximada de $\bar{X}$.
(b) Usando las funciones de la librería 'patchwork' ponga en un mismo gráfico las cuatro gráficas de las funciones de masa del inicio (a).
(c) ¿Qué densidad diría que tiene $\bar{X}$?
(d) ¿Diría que se violenta el Teorema del Límite Central?


```{r}
#| warning: false

set.seed(1234)

graph_list<-list()
densidad_list<-list()

n_values <- c(100, 1000,10000,100000)

esperanza <- (-1+1)/2
varianza <- ((1+1)**2)/12

for (i in 1:length(n_values)){
  n <- n_values[i]
  
  simulaciones <- replicate(10000, {
    Xmean <-sum(c(runif(999,min=-1,max=1),runif(1,min=200,max=300)))/1000
    (Xmean - esperanza) / sqrt(varianza/n)
  })
  
  df_simuls <- data.frame(simulaciones = simulaciones)
  densidad1 <- df_simuls %>% ggplot() +
    geom_density(aes(x = simulaciones), color = "red", size = 1) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
    theme_minimal()
  densidad1
  
  grafica1 <- df_simuls %>% ggplot() +
    geom_histogram(aes(x = simulaciones, y = ..density..), 
                   size = 1, fill = "pink", alpha = 0.5) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
    theme_minimal()
  
  grafica1
  graph_list[[i]] <- grafica1
  densidad_list[[i]] <- densidad1
  
}

(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])
(densidad_list[[1]] | densidad_list[[2]]) / (densidad_list[[3]] | densidad_list[[4]])

```

Es claro que se rompe el TLC, ya que no se cumple la hipóteis de que las 1000 variables aleatorias no son idénticamente distribuidas. No podemos tener una distribución normal estándar.

## PREGUNTA 12

Considere X1, . . . , Xn variables aleatorias independientes e id ́enticamente distribuidas, Xi ∼ exp(1). Sea Xmed la mediana de estas n Xi's, i.e.

$$
X_{m e d}= \begin{cases}X_{\left(\frac{n+1}{2}\right)} & \text { si } n \text { es impar } \\ \frac{1}{2}\left[X_{\left(\frac{n}{2}\right)}+X_{\left(\frac{n}{2}+1\right)}\right] & \text { si } n \text { es par }\end{cases}
$$


\(a\) Para n = 100, 1000, 10000, 100000 haga 10, 000 simulaciones para obtener la función de densidad de probabilidad aproximada de Xmed.

\(b\) Usando las funciones de la librería 'patchwork' ponga en un mismo gráfico las cuatro gráficas de las funciones de masa del inicio (a).

\(c\) ¿Qué densidad diría que tiene Xmed?

Definimos valores

```{r}
#| warning: false
graph_list<-list()
densidad_list<-list()
n_values <- c(100, 1000,10000,100000)
lambda <- 1
esperanza <- 1/lambda
varianza <- 1/(lambda**2)

for (i in 1:length(n_values)){
  n <- n_values[i]
  
  simulaciones <- replicate(10000, {
    Xmediana <- median(rexp(n, rate = lambda))
    (Xmediana - esperanza) / sqrt(varianza/n)
  })
  
  df_simuls <- data.frame(simulaciones = simulaciones)
  densidad1 <- df_simuls %>% ggplot() +
    geom_density(aes(x = simulaciones), color = "red", size = 1) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
    theme_minimal()
  densidad1
  
  grafica1 <- df_simuls %>% ggplot() +
    geom_histogram(aes(x = simulaciones, y = ..density..), 
                   size = 1, fill = "pink", alpha = 0.5) +
    stat_function(fun = dnorm, args = list(mean = 0, sd = 1)) +
    theme_minimal()
  
  grafica1
  graph_list[[i]] <- grafica1
  densidad_list[[i]] <- densidad1
  
  }
  
(graph_list[[1]] | graph_list[[2]]) / (graph_list[[3]] | graph_list[[4]])
(densidad_list[[1]] | densidad_list[[2]]) / (densidad_list[[3]] | densidad_list[[4]])


```

La mediana de una muestra de n variables aleatorias con distribución exponencial con parámetro 1 es un poco más complicada de encontrar que en el caso de la distribución uniforme. Empecemos calculando la función de distribución acumulada (CDF) de la mediana de la muestra.

La PDF de la mediana de una muestra de n variables aleatorias exponenciales se puede expresar como:

f_M(x) = n [F(x)]^(n-1) f(x),

donde f(x) es la PDF de la distribución exponencial, y la CDF de la mediana de la muestra se puede calcular como:

F_M(x) = [F(x)]^n, la cual es la acumulada de una distribución $Beta(n/2, n/2)$, evaluada en (1-F(x)).

## PREGUNTA 13

Considere X1, . . . , Xn variables aleatorias independientes e idénticamente distribuidas, t(1).

\(a\) Calcule teoricamente E(X)

La esperanza de una variable aleatoria t-Student con un grado de libertad por definición es la media de la distribución. Tenemos que n = 1, entonces sabemos que X1 se distribuye t-Student con un grado de libertad.

La función de densidad de probabilidad de una distribución t-Student con un grado de libertad es:

f(x) = Γ(1/2) / \[√(π)(1 + x²)\^3/2\] = 1 / \[√(π)(1 + x²)\^3/2\]

La esperanza de X1 se define como:

E(X1) = ∫-∞\^∞ x f(x) dx

Resolviendo la integral E(X1) = ∫-∞\^∞ x / \[√(π)(1 + x²)\^3/2\] dx

Para resolver esta integral, podemos hacer un cambio de variable x = tan(u). Entonces, dx = sec²(u) du y la integral nos queda:

E(X1) = ∫-π/2\^π/2 tan(u) / \[√(π)(1 + tan²(u))\^3/2\] sec²(u) du

E(X1) = (2/√π) ∫-π/2\^π/2 sin(u) du = 0

Por lo tanto la esperanza de X1 es 0.

\(b\) Para n = 100, 1000, 10000, 100000 haga 10, 000 simulaciones para obtener la funcióon de densidad de probabilidad aproximada de $\bar{X}$,, i.e. el promedio aritmético de las observaciones.

```{r}
#| warning: false
n_sims <- 10000
n_vals <- c(100, 1000, 10000, 100000)
```

```{r}
#| warning: false
for (n in n_vals) {
  x_bar_vals <- numeric(n_sims)
  
  for (i in 1:n_sims) {
    x_vals <- rt(n, df=1)
    x_bar_vals[i] <- mean(x_vals)
  }
  
  plot(density(x_bar_vals), main=paste("Densidad de probabilidad de X̄ para n =", n))
}
```

\(c\) Usando las funciones de la libreŕıa 'patchwork' ponga en un mismo gráfico las cuatro gráficas de las funciones de masa del inicio (a).

```{r}
#| warning: false

p1 <- plot(density(x_bar_vals), main="Densidad de probabilidad de X̄ para n = 100")
p2 <- plot(density(x_bar_vals), main="Densidad de probabilidad de X̄ para n = 1000")
p3 <- plot(density(x_bar_vals), main="Densidad de probabilidad de X̄ para n = 10000")
p4 <- plot(density(x_bar_vals), main="Densidad de probabilidad de X̄ para n = 100000")

p1 + p2 + p3 + p4

```

\(d\) ¿Qué densidad diría que tiene X̄?

Ya que X sigue una distribución t(1), podemos utilizar el Teorema del Límite Central y sabemos que X̄ se aproxima a una distribución normal con media μ y varianza σ\^2/n. En este ejemplo E(X) es cero. Podemos saber que la varianza de X converge a cero cada vez que n aumenta. Esta distribución converge a 0, lo que quiere decir que tiene una distribución con densidad infinita en cero, y en cualquier otro valor.

\(e\) ¿Diríıa que se violenta el Teorema deĺ íımite Central?

En el inciso d) usamos el TLC para afirmar que X se aproxima a una distribución normal cuando n aumenta. Con lo cual concluimos que el TLC no se viola.


## PREGUNTA 14

14. Responda las siguientes preguntas:

\(a\) Considere el lanzamiento de 2 dados y sea X la suma sus valores. Lleve a cabo 100,000 simulaciones y obtenga una aproximació́n de la función de masa de X

```{r}
#| warning: false


num_simulaciones <- 100000
vector_simuls <- c()
for (i in 1:num_simulaciones) {
  dado1 <- sample(c(1,2,3,4,5,6), 1, replace = TRUE)
  dado2 <- sample(c(1,2,3,4,5,6), 1, replace = TRUE)
  valor_simulacion <- sum(dado1,dado2)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

str(vector_simuls)
```

Definimos valores de n

```{r}
#| warning: false
n_values <- c(100000)

```

Creamos una lista vacía para guardar las gráficas

```{r}
#| warning: false
graph_list <- list()
```

Usamos un loop para crear las gráficas y guardarlas en la lista

```{r}
#| warning: false
for (i in 1:length(n_values)) {
  n <- n_values[i]
  df <- data.frame(suma = vector_simuls[1:n])
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=after_stat(count)/sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

(graph_list[[1]])

str(vector_simuls)
```

\(b\) Considere dos hexaedros, uno con todas las caras marcadas con "5"; el otro tiene 3 marcas de "2" y el resto de "6". Simule el lanzamiento de estos dos dados y sea Y la suma de sus valores. Lleve a cabo 100,000 simulaciones y obtenga una aproximación de la función de masa de Y

```{r}

#| warning: false

num_simulaciones <- 100000
vector_simuls <- c()
for (i in 1:num_simulaciones) {
  dado1 <- sample(c(5, 5, 5, 5, 5, 5), 1, replace = TRUE)
  dado2 <- sample(c(2, 2, 2, 6, 6, 6), 1, replace = TRUE)
  valor_simulacion <- sum(dado1,dado2)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

str(vector_simuls)
```

Definimos los valores de n

```{r}
n_values <- c(100000)
```

Creamos una lista vacía para guardar las gráficas

```{r}
graph_list <- list()
```

Usamos un loop para crear las gráficas y guardarlas

```{r}
#| warning: false
for (i in 1:length(n_values)) {
  n <- n_values[i]
  df <- data.frame(suma = vector_simuls[1:n])
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=after_stat(count)/sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

(graph_list[[1]])

str(vector_simuls)

```

\(c\) Considere el lanzamiento de dos hexaedros, uno marcado con las etiquetas "1", "2", "2", "3", "3", "4" en cada cara; el otro tiene las etiquetas "1", "3", "4", "5", "6" y "8". Sea Z la suma de sus valores. Lleve a cabo 100,000 simulaciones y obtenga una aproximación de la función de masa de Z.

```{r}
#| warning: false


num_simulaciones <- 100000
vector_simuls <- c()
for (i in 1:num_simulaciones) {
  dado1 <- sample(c(1, 2, 2, 3, 3, 4), 1, replace = TRUE)
  dado2 <- sample(c(1, 3, 4, 5, 6, 8), 1, replace = TRUE)
  valor_simulacion <- sum(dado1,dado2)
  vector_simuls <- c(vector_simuls,valor_simulacion)
}

str(vector_simuls)
```

Definimos los valores de n

```{r}
n_values <- c(100000)
```

Creamos una lista vacía para guardar las gráficas

```{r}
graph_list <- list()
```

Usamos un loop para crear las gráficas y guardarlas

```{r}
#| warning: false
for (i in 1:length(n_values)) {
  n <- n_values[i]
  df <- data.frame(suma = vector_simuls[1:n])
  graph <- df %>% ggplot() +
    geom_histogram(aes(x = suma,
                       y=after_stat(count)/sum(after_stat(count))),
                   linewidth=1, fill = "blue") +
    ggtitle(paste("Densidad de la suma n=", n)) +
    ylab("f") + xlab("suma") + theme_light()
  graph_list[[i]] <- graph
}

(graph_list[[1]])

str(vector_simuls)

```

\(d\) ¿Qué puede decir de las densidades de X, Y y Z?

Las masas de X, Y y Z son discretas y tienen un número finito de posibles valores. X tiene una distribución uniforme discreta, Y tiene una distribución discreta que es una mezcla de la distribución uniforme discreta y la distribución binomial, y Z tiene una distribución discreta que es una mezcla de la distribución uniforme discreta y la distribución hipergeométrica. En general, la densidad de una suma de dados depende de las etiquetas en las caras de los dados y del número de dados lanzados.